generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    String                     @id @default(cuid())
  email                 String?                    @unique
  emailVerified         DateTime?
  image                 String?
  name                  String?
  subscribed            Boolean?                   @default(false)
  createdAt             DateTime                   @default(now())
  updatedAt             DateTime                   @updatedAt
  theme                 String?                    @default("light")
  emailFrequency        String?                    @default("daily")
  emailSubscribedAt     DateTime?
  lastEmailSent         DateTime?
  subscriptionEmail     String?
  unsubscribedAt        DateTime?
  alias                 String?                    @unique
  isAliasPublic         Boolean                    @default(false)
  aliasCreatedAt        DateTime?
  currentAliasId        String?                    @unique
  accounts              Account[]
  bookmarks             Bookmark[]
  dailySummaries        DailySummary[]
  responses             GPTResponse[]
  sessions              Session[]
  languagePreference    UserLanguagePreference?
  languageSubscriptions UserLanguageSubscription[]
  communityResponses    CommunityResponse[]
  communityImports      CommunityImport[]
  aliases               UserAlias[]
  currentAlias          UserAlias?                 @relation("CurrentUserAlias", fields: [currentAliasId], references: [id])
  streak                Streak?
}

model Account {
  id                String   @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([identifier, token])
}

model Language {
  id                String                     @id @default(cuid())
  code              String                     @unique
  name              String
  isActive          Boolean                    @default(true)
  createdAt         DateTime                   @default(now())
  updatedAt         DateTime                   @updatedAt
  bookmarks         Bookmark[]
  dailySummaries    DailySummary[]
  responses         GPTResponse[]
  userPreferences   UserLanguagePreference[]
  subscriptions     UserLanguageSubscription[]
  communityResponses CommunityResponse[]
}

model UserLanguagePreference {
  id         String   @id @default(cuid())
  userId     String   @unique
  languageId String
  updatedAt  DateTime @updatedAt
  createdAt  DateTime @default(now())
  language   Language @relation(fields: [languageId], references: [id])
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model UserLanguageSubscription {
  id                String    @id @default(cuid())
  userId            String
  languageId        String
  subscribed        Boolean   @default(false)
  subscriptionEmail String?
  emailFrequency    String    @default("daily")
  lastEmailSent     DateTime?
  emailSubscribedAt DateTime?
  unsubscribedAt    DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  language          Language  @relation(fields: [languageId], references: [id], onDelete: Cascade)
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, languageId])
}

model GPTResponse {
  id                  String               @id @default(cuid())
  content             String
  createdAt           DateTime             @default(now())
  userId              String
  rank                Int?                 @default(1)
  languageId          String
  isPaused            Boolean              @default(false)
  updatedAt           DateTime             @updatedAt
  audio               String?
  audioMimeType       String?
  breakdown           String?
  furigana            String?
  isFuriganaEnabled   Boolean              @default(false)
  isPhoneticEnabled   Boolean              @default(true)
  isKanaEnabled       Boolean              @default(true)
  mobileBreakdown     String?
  responseType        String               @default("response")
  source              String               @default("local")
  communityResponseId String?
  language            Language             @relation(fields: [languageId], references: [id])
  user                User                 @relation(fields: [userId], references: [id])
  bookmarks           Bookmark[]           @relation("BookmarksToResponses")
  dailySummaries      DailySummary[]       @relation("DailySummaryToResponses")
  communityResponse   CommunityResponse?   @relation("ImportedResponses", fields: [communityResponseId], references: [id])
  originalCommunityPost CommunityResponse? @relation("OriginalResponses")
  communityImport     CommunityImport?
}

model Bookmark {
  id               String            @id @default(cuid())
  title            String
  userId           String
  languageId       String
  isReserved       Boolean           @default(false)
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  language         Language          @relation(fields: [languageId], references: [id])
  user             User              @relation(fields: [userId], references: [id])
  responses        GPTResponse[]     @relation("BookmarksToResponses")
  communityImports CommunityImport[]
}

model DailySummary {
  id         String        @id @default(cuid())
  userId     String
  languageId String
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  language   Language      @relation(fields: [languageId], references: [id])
  user       User          @relation(fields: [userId], references: [id])
  responses  GPTResponse[] @relation("DailySummaryToResponses")
}

model CommunityResponse {
  id                String            @id @default(cuid())
  originalResponseId String           @unique
  creatorAlias      String
  creatorUserId     String
  bookmarkTitle     String
  languageId        String
  content           String
  breakdown         String?
  mobileBreakdown   String?
  furigana          String?
  audio             String?
  audioMimeType     String?
  isActive          Boolean           @default(true)
  importCount       Int               @default(0)
  viewCount         Int               @default(0)
  sharedAt          DateTime          @default(now())
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  
  creator           User              @relation(fields: [creatorUserId], references: [id])
  language          Language          @relation(fields: [languageId], references: [id])
  originalResponse  GPTResponse       @relation("OriginalResponses", fields: [originalResponseId], references: [id], onDelete: Cascade)
  importedResponses GPTResponse[]     @relation("ImportedResponses")
  imports           CommunityImport[]
  
  @@index([languageId, sharedAt])
  @@index([creatorUserId])
  @@index([bookmarkTitle])
  @@index([importCount])
}

model CommunityImport {
  id                  String            @id @default(cuid())
  userId              String
  communityResponseId String
  importedResponseId  String            @unique
  importedBookmarkId  String
  wasBookmarkCreated  Boolean           @default(false)
  importedAt          DateTime          @default(now())
  
  user                User              @relation(fields: [userId], references: [id])
  communityResponse   CommunityResponse @relation(fields: [communityResponseId], references: [id])
  importedResponse    GPTResponse       @relation(fields: [importedResponseId], references: [id], onDelete: Cascade)
  importedBookmark    Bookmark          @relation(fields: [importedBookmarkId], references: [id])
  
  @@unique([userId, communityResponseId])
}

model UserAlias {
  id                String    @id @default(cuid())
  userId            String
  alias             String    @unique
  isCurrentlyActive Boolean   @default(false)
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  currentUser       User?     @relation("CurrentUserAlias")
  
  @@index([userId])
  @@index([alias])
}

model Streak {
  id              String   @id @default(cuid())
  userId          String   @unique
  currentStreak   Int      @default(0)
  maxStreak       Int      @default(0)
  lastActivityDate DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
}
